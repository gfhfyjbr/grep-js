/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * A compiled regex matcher.
 *
 * Use `RegexMatcherBuilder` to construct this.
 */
export declare class RegexMatcher {
  /** Create a new matcher from a pattern with default options. */
  static fromPattern(pattern: string): RegexMatcher
  /** Check if the given text matches the pattern. */
  isMatch(text: string | Buffer): boolean
  /**
   * Find the first match in the given text.
   *
   * Returns the start and end byte offsets, or null if no match.
   */
  find(text: string | Buffer): MatchRange | null
  /** Find all matches in the given text. */
  findAll(text: string | Buffer): Array<MatchRange>
}

/**
 * Builder for constructing a RegexMatcher.
 *
 * This builder re-exports many of the same options found on the regex crate's
 * builder, in addition to options like smart case, word matching, and line
 * terminator settings.
 */
export declare class RegexMatcherBuilder {
  /** Create a new builder with default configuration. */
  constructor()
  /** Build a new matcher for the provided pattern. */
  build(pattern: string): RegexMatcher
  /** Build a new matcher from multiple patterns (joined as alternation). */
  buildMany(patterns: Array<string>): RegexMatcher
  /** Build a new matcher from literal strings (optimized alternation). */
  buildLiterals(literals: Array<string>): RegexMatcher
  /**
   * Set the value for the case insensitive (`i`) flag.
   *
   * When enabled, letters in the pattern will match both upper case and
   * lower case variants.
   */
  caseInsensitive(yes: boolean): this
  /**
   * Whether to enable "smart case" or not.
   *
   * When smart case is enabled, the builder will automatically enable
   * case insensitive matching based on how the pattern is written.
   * Specifically, case insensitive mode is enabled when:
   * 1. The pattern contains at least one literal character.
   * 2. Of the literals in the pattern, none of them are uppercase.
   */
  caseSmart(yes: boolean): this
  /**
   * Set the value for the multi-line matching (`m`) flag.
   *
   * When enabled, `^` matches the beginning of lines and `$` matches
   * the end of lines.
   */
  multiLine(yes: boolean): this
  /**
   * Set the value for the any character (`s`) flag.
   *
   * When enabled, `.` matches any character including newlines.
   */
  dotMatchesNewLine(yes: boolean): this
  /**
   * Set the value for the greedy swap (`U`) flag.
   *
   * When enabled, `a*` is lazy and `a*?` is greedy.
   */
  swapGreed(yes: boolean): this
  /**
   * Set the value for the ignore whitespace (`x`) flag.
   *
   * When enabled, whitespace and comments in the pattern are ignored.
   */
  ignoreWhitespace(yes: boolean): this
  /**
   * Set the value for the Unicode (`u`) flag.
   *
   * When disabled, character classes like `\w` only match ASCII.
   */
  unicode(yes: boolean): this
  /**
   * Whether to support octal syntax or not.
   *
   * Octal syntax is disabled by default.
   */
  octal(yes: boolean): this
  /** Set the approximate size limit of the compiled regular expression. */
  sizeLimit(bytes: number): this
  /** Set the approximate size of the cache used by the DFA. */
  dfaSizeLimit(bytes: number): this
  /** Set the nesting limit for the parser. */
  nestLimit(limit: number): this
  /**
   * Set an ASCII line terminator for the matcher.
   *
   * When set, the matcher will never produce a match containing this byte.
   */
  lineTerminator(byte?: number | undefined | null): this
  /**
   * Ban a byte from occurring in a pattern.
   *
   * If this byte is found in the pattern, an error will be returned.
   */
  banByte(byte?: number | undefined | null): this
  /**
   * Set CRLF mode for line terminators.
   *
   * When enabled, `$` will match both `\r
  ` and `
  `.
   */
  crlf(yes: boolean): this
  /** Require that all matches occur on word boundaries. */
  word(yes: boolean): this
  /**
   * Whether the patterns should be treated as literal strings.
   *
   * When enabled, all regex meta characters are matched literally.
   */
  fixedStrings(yes: boolean): this
  /**
   * Whether each pattern should match the entire line.
   *
   * Equivalent to surrounding the pattern with `(?m:^)` and `(?m:$)`.
   */
  wholeLine(yes: boolean): this
}

/**
 * A searcher executes searches over a haystack and collects results.
 *
 * Use `SearcherBuilder` to construct this with custom configuration.
 */
export declare class Searcher {
  /** Create a new searcher with default configuration. */
  constructor()
  /** Search a file for matches. */
  searchPath(matcher: RegexMatcher, path: string): SearchResult
  /** Search a byte slice for matches. */
  searchSlice(matcher: RegexMatcher, slice: string | Buffer): SearchResult
  /** Search a reader for matches. */
  searchReader(matcher: RegexMatcher, data: Buffer): SearchResult
}

/**
 * Builder for configuring a Searcher.
 *
 * A search builder permits specifying configuration options like whether to
 * invert the search, enable multi-line search, or configure context lines.
 */
export declare class SearcherBuilder {
  /** Create a new builder with default configuration. */
  constructor()
  /** Build a searcher with the current configuration. */
  build(): Searcher
  /**
   * Set the line terminator used by the searcher.
   *
   * By default, this is `
  ` (byte value 10).
   */
  lineTerminator(byte: number): this
  /**
   * Whether to invert matching.
   *
   * When enabled, non-matching lines are reported instead of matching lines.
   */
  invertMatch(yes: boolean): this
  /**
   * Whether to count and include line numbers with matching lines.
   *
   * Enabled by default.
   */
  lineNumber(yes: boolean): this
  /**
   * Whether to enable multi-line search.
   *
   * When enabled, matches may span multiple lines.
   * Warning: requires loading entire file into memory.
   */
  multiLine(yes: boolean): this
  /** Number of context lines to include after each match. */
  afterContext(lineCount: number): this
  /** Number of context lines to include before each match. */
  beforeContext(lineCount: number): this
  /**
   * Whether to enable passthru mode.
   *
   * When enabled, all non-matching lines are reported as context.
   */
  passthru(yes: boolean): this
  /**
   * Set an approximate heap limit in bytes.
   *
   * Set to 0 to disable heap usage (requires memory maps for large files).
   */
  heapLimit(bytes?: number | undefined | null): this
  /**
   * Set binary detection mode.
   *
   * - "None": No binary detection
   * - "Quit": Stop searching when binary data is detected
   * - "Convert": Convert NUL bytes to line terminators
   */
  binaryDetection(mode: BinaryDetectionMode): this
  /**
   * Enable automatic BOM sniffing for encoding detection.
   *
   * When enabled, UTF-16 files with BOM will be searched correctly.
   */
  bomSniffing(yes: boolean): this
  /**
   * Stop searching when a non-matching line is found after a matching line.
   *
   * Useful for searching sorted files.
   */
  stopOnNonmatch(yes: boolean): this
  /** Set the maximum number of matches to return. */
  maxMatches(limit?: number | undefined | null): this
}

/** Binary detection mode. */
export declare const enum BinaryDetectionMode {
  /** No binary detection. */
  None = 'None',
  /** Quit searching when binary data is detected. */
  Quit = 'Quit',
  /** Convert binary data to text (replace NUL bytes). */
  Convert = 'Convert'
}

/** The kind of context reported by a searcher. */
export declare const enum ContextKind {
  /** Context before a match. */
  Before = 'Before',
  /** Context after a match. */
  After = 'After',
  /** Other context (e.g., passthru mode). */
  Other = 'Other'
}

/** Find the first match of a pattern in the given text. */
export declare function find(pattern: string, text: string | Buffer): MatchRange | null

/** Find all matches of a pattern in the given text. */
export declare function findAll(pattern: string, text: string | Buffer): Array<MatchRange>

/** Check if a pattern matches anywhere in the given text. */
export declare function isMatch(pattern: string, text: string | Buffer): boolean

/** A single match found in a line. */
export interface MatchRange {
  /** Start byte offset within the line. */
  start: number
  /** End byte offset within the line. */
  end: number
}

/**
 * Search a string/buffer for a pattern with default options.
 *
 * This is a convenience function for simple searches.
 */
export declare function search(pattern: string, haystack: string | Buffer): SearchResult

/** Represents a context line (before/after a match). */
export interface SearchContext {
  /** The line number (1-based), if line numbers are enabled. */
  lineNumber?: number
  /** The absolute byte offset of the start of this context line. */
  absoluteByteOffset: number
  /** The context line content. */
  line: string
  /** The bytes of the context line. */
  bytes: Buffer
  /** The kind of context (before, after, other). */
  kind: ContextKind
}

/** Search a file for a pattern with default options. */
export declare function searchFile(pattern: string, path: string): SearchResult

/** Summary information returned after a search completes. */
export interface SearchFinish {
  /** The absolute byte offset of the end of the search. */
  byteCount: number
  /** Whether binary data was detected (if binary detection is enabled). */
  binaryByteOffset?: number
}

/** Represents a matching line found by the searcher. */
export interface SearchMatch {
  /** The line number (1-based), if line numbers are enabled. */
  lineNumber?: number
  /** The absolute byte offset of the start of this match. */
  absoluteByteOffset: number
  /** The matched line content. */
  line: string
  /** The bytes of the matched line. */
  bytes: Buffer
  /** All match ranges within the line. */
  matches: Array<MatchRange>
}

/** Complete search result containing all matches and context. */
export interface SearchResult {
  /** All matching lines. */
  matches: Array<SearchMatch>
  /** All context lines. */
  context: Array<SearchContext>
  /** Summary information. */
  finish: SearchFinish
}
